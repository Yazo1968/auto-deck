import React, { useState, useEffect } from 'react';
import { UploadedFile, InsightsSession, Nugget, Project, InitialPersistedState, CustomStyle } from '../types';
import { AppProvider } from '../context/AppContext';
import { useNuggetContext } from '../context/NuggetContext';
import { useProjectContext } from '../context/ProjectContext';
import { useSelectionContext } from '../context/SelectionContext';
import { useStyleContext } from '../context/StyleContext';
import { IndexedDBBackend } from '../utils/storage/IndexedDBBackend';
import { StorageBackend } from '../utils/storage/StorageBackend';
import {
  deserializeFile,
  deserializeCard,
  deserializeNugget,
  deserializeNuggetDocument,
  deserializeProject,
  serializeCard,
  serializeNugget,
  serializeNuggetDocument,
  serializeProject,
  extractImages,
} from '../utils/storage/serialize';
import { usePersistence } from '../hooks/usePersistence';
import { LoadingScreen } from './LoadingScreen';

// ── Singleton storage instance (exported for direct use by useTokenUsage) ──

export const storage: StorageBackend = new IndexedDBBackend();

// ── Persistence connector (auto-save, renders nothing) ──

const PersistenceConnector: React.FC = () => {
  const { nuggets, selectedNuggetId, selectedDocumentId } = useNuggetContext();
  const { projects } = useProjectContext();
  const { activeCardId, selectedProjectId } = useSelectionContext();
  const { customStyles } = useStyleContext();

  usePersistence({
    storage,
    activeCardId,
    nuggets,
    projects,
    selectedNuggetId,
    selectedDocumentId,
    selectedProjectId,
    customStyles,
  });

  return null;
};

// ── Startup integrity check: clean up orphaned data ──

async function cleanupOrphanedData(storageBackend: StorageBackend, hydratedNuggetIds: Set<string>): Promise<void> {
  try {
    // Find nugget IDs in storage that weren't hydrated (orphans from crash/incomplete save)
    const storedNuggetIds = await storageBackend.loadAllNuggetIds();
    let orphanCount = 0;
    for (const id of storedNuggetIds) {
      if (!hydratedNuggetIds.has(id)) {
        console.warn(`[Storage] Cleaning up orphaned nugget: ${id}`);
        await storageBackend.deleteNugget(id);
        await storageBackend.deleteNuggetDocuments(id);
        await storageBackend.deleteNuggetHeadings(id);
        await storageBackend.deleteNuggetImages(id);
        orphanCount++;
      }
    }
    if (orphanCount > 0) {
      console.log(`[Storage] Cleaned up ${orphanCount} orphaned nugget(s)`);
    }

    // Belt and suspenders: clear any remaining legacy store data
    await storageBackend.clearLegacyStores();
  } catch (err) {
    // Non-fatal — log and continue, don't block app startup
    console.warn('[Storage] Orphan cleanup failed (non-fatal):', err);
  }
}

// ── Hydration logic ──

async function hydrateFromStorage(): Promise<InitialPersistedState | null> {
  await storage.init();

  // Load from all stores in parallel
  const [
    appState,
    storedFiles,
    insightsSessionData,
    insightsDocs,
    insightsHeadingsStored,
    insightsImagesStored,
    storedNuggets,
    storedProjects,
    storedTokenUsage,
    storedCustomStyles,
  ] = await Promise.all([
    storage.loadAppState(),
    storage.loadFiles(),
    storage.loadInsightsSession(),
    storage.loadInsightsDocs(),
    storage.loadInsightsHeadings(),
    storage.loadInsightsImages(),
    storage.loadNuggets(),
    storage.loadProjects(),
    storage.loadTokenUsage(),
    storage.loadCustomStyles(),
  ]);

  console.log('[Storage] Raw stores:', {
    storedNuggets: storedNuggets.length,
    storedProjects: storedProjects.length,
    storedFiles: storedFiles.length,
    hasInsightsSession: !!insightsSessionData,
  });

  // Reconstitute insights session (legacy stores)
  let insightsSession: InsightsSession | null = null;
  if (insightsSessionData) {
    const iHeadings = insightsHeadingsStored.map((sh) => deserializeCard(sh, insightsImagesStored));
    insightsSession = {
      id: insightsSessionData.id,
      documents: insightsDocs,
      messages: insightsSessionData.messages,
      cards: iHeadings,
    };
  }

  // Reconstitute nuggets — load headings, images, and documents per-nugget
  let nuggets: Nugget[] = [];
  for (const sn of storedNuggets) {
    const [headings, images, nuggetDocs] = await Promise.all([
      storage.loadNuggetHeadings(sn.id),
      storage.loadNuggetImages(sn.id),
      storage.loadNuggetDocuments(sn.id),
    ]);
    const hydratedHeadings = headings.map((sh) => deserializeCard(sh, images));
    const hydratedDocs = nuggetDocs.map((sd) => deserializeNuggetDocument(sd));
    nuggets.push(deserializeNugget(sn, hydratedHeadings, hydratedDocs));
  }

  // ── Runtime migration: v2 data → v3 (documents were in global library, nuggets had documentIds) ──
  const nuggetsNeedDocMigration = nuggets.length > 0 && nuggets.every((n) => n.documents.length === 0);
  if (nuggetsNeedDocMigration) {
    const oldDocuments = await storage.loadDocuments();
    if (oldDocuments.length > 0) {
      console.log(`[Storage] Migrating v2→v3: ${oldDocuments.length} documents to embed in nuggets`);
      const docMap = new Map(oldDocuments.map((sd) => [sd.id, deserializeFile(sd)]));

      for (const nugget of nuggets) {
        const rawNugget = storedNuggets.find((sn) => sn.id === nugget.id) as any;
        const oldDocIds: string[] = rawNugget?.documentIds ?? [];
        if (oldDocIds.length > 0) {
          nugget.documents = oldDocIds.map((id) => docMap.get(id)).filter((d): d is UploadedFile => d !== undefined);
          for (const doc of nugget.documents) {
            await storage.saveNuggetDocument(serializeNuggetDocument(nugget.id, doc));
          }
          await storage.saveNugget(serializeNugget(nugget));
        }
      }
      console.log(`[Storage] v2→v3 migration complete`);
    }
  }

  // ── Runtime migration: v1 data (files + insightsSession but no nuggets) → nuggets ──
  if (nuggets.length === 0 && (storedFiles.length > 0 || insightsSession)) {
    const now = Date.now();

    // Migrate old files → insights nuggets (convert synthesis type to insights)
    for (const sf of storedFiles) {
      if (sf.status !== 'ready') continue;
      const [headings, images] = await Promise.all([storage.loadHeadings(sf.id), storage.loadImages(sf.id)]);
      if (headings.length > 0) {
        const hydratedHeadings = headings.map((sh) => deserializeCard(sh, images));
        const file = deserializeFile(sf, hydratedHeadings);
        const nuggetId = `migrated-${sf.id}`;
        const nugget: Nugget = {
          id: nuggetId,
          name: sf.name.replace(/\.\w+$/, ''),
          type: 'insights',
          documents: [file],
          cards: hydratedHeadings,
          messages: [],
          createdAt: now,
          lastModifiedAt: now,
        };
        nuggets.push(nugget);

        await storage.saveNugget(serializeNugget(nugget));
        await storage.saveNuggetDocument(serializeNuggetDocument(nuggetId, file));
        const storedH = nugget.cards.map((h) => serializeCard(h, nuggetId));
        await storage.saveNuggetHeadings(nuggetId, storedH);
        for (const h of nugget.cards) {
          const imgs = extractImages(h, nuggetId);
          for (const img of imgs) {
            await storage.saveNuggetImage(img);
          }
        }
      }
    }

    // Migrate insights session → insights nugget
    if (insightsSession) {
      const nuggetId = `migrated-insights-${insightsSession.id}`;
      const insightsDocs: UploadedFile[] = insightsSession.documents.map((doc) => ({
        id: doc.id,
        name: doc.name,
        size: doc.size,
        type: doc.type === 'pdf' ? 'application/pdf' : 'text/markdown',
        lastModified: now,
        content: doc.content,
        status: 'ready' as const,
        progress: 100,
      }));

      const nugget: Nugget = {
        id: nuggetId,
        name: 'Migrated Insights',
        type: 'insights',
        documents: insightsDocs,
        cards: insightsSession.cards,
        messages: insightsSession.messages,
        createdAt: now,
        lastModifiedAt: now,
      };
      nuggets.push(nugget);

      await storage.saveNugget(serializeNugget(nugget));
      for (const doc of insightsDocs) {
        await storage.saveNuggetDocument(serializeNuggetDocument(nuggetId, doc));
      }
      const storedH = nugget.cards.map((h) => serializeCard(h, nuggetId));
      await storage.saveNuggetHeadings(nuggetId, storedH);
      for (const h of nugget.cards) {
        const imgs = extractImages(h, nuggetId);
        for (const img of imgs) {
          await storage.saveNuggetImage(img);
        }
      }
    }

    console.log(`[Storage] Migrated v1→v3: ${nuggets.length} nuggets created`);
  }

  // ── Migration: convert any remaining synthesis-type nuggets to insights ──
  for (const nugget of nuggets) {
    if ((nugget.type as string) === 'synthesis') {
      (nugget as any).type = 'insights';
      if (!nugget.messages) nugget.messages = [];
      await storage.saveNugget(serializeNugget(nugget));
    }
  }

  // ── Reconstitute projects ──
  let projects: Project[] = storedProjects.map((sp) => deserializeProject(sp));

  // ── Migration: existing nuggets but no projects → create default project ──
  if (projects.length === 0 && nuggets.length > 0) {
    const now = Date.now();
    const defaultProject: Project = {
      id: `project-${now}-${Math.random().toString(36).substr(2, 9)}`,
      name: 'My Project',
      nuggetIds: nuggets.map((n) => n.id),
      createdAt: now,
      lastModifiedAt: now,
    };
    projects = [defaultProject];
    await storage.saveProject(serializeProject(defaultProject));
    console.log(`[Storage] Migrated nuggets→project: created default "My Project" with ${nuggets.length} nuggets`);
  }

  // ── Startup integrity check: clean up orphaned data ──
  const hydratedNuggetIds = new Set(nuggets.map((n) => n.id));
  await cleanupOrphanedData(storage, hydratedNuggetIds);

  // Only return state if there's actually data to restore
  if (nuggets.length === 0 && !storedTokenUsage) return null;

  return {
    nuggets,
    projects,
    selectedNuggetId: appState?.selectedNuggetId ?? null,
    selectedDocumentId: appState?.selectedDocumentId ?? null,
    selectedProjectId: appState?.selectedProjectId ?? null,
    activeCardId: appState?.activeCardId ?? null,
    workflowMode: 'insights',
    tokenUsageTotals: storedTokenUsage as Record<string, number> | undefined,
    customStyles: (storedCustomStyles as CustomStyle[] | null) ?? undefined,
  };
}

// ── Provider component ──

export const StorageProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [initialState, setInitialState] = useState<InitialPersistedState | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;

    hydrateFromStorage()
      .then((state) => {
        console.log(
          '[Storage] Hydration result:',
          state ? `${state.nuggets.length} nuggets, ${state.projects.length} projects` : 'null (no data)',
        );
        if (!cancelled) setInitialState(state);
      })
      .catch((err) => {
        console.error('[Storage] Hydration failed, starting fresh:', err);
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
    };
  }, []);

  if (loading) {
    return <LoadingScreen />;
  }

  return (
    <AppProvider initialState={initialState ?? undefined}>
      <PersistenceConnector />
      {children}
    </AppProvider>
  );
};
