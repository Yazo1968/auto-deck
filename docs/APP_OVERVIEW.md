# App Overview

## Purpose

InfoNugget v6.0 is a browser-based single-page application that transforms documents (PDF and Markdown) into AI-generated infographic cards. Users upload source documents into isolated workspaces called nuggets, chat with an AI about the document content, select headings or topics to turn into visual cards, and generate styled infographic images from those cards using a three-phase AI pipeline (content synthesis via Claude, layout planning via Claude or Gemini Flash, and image generation via Gemini Pro Image). The result is a set of shareable visual cards — each grounded in the source material — without requiring any design skills.

## Target Users

Knowledge workers, consultants, and analysts who need to distill large documents (reports, whitepapers, research papers, presentations) into concise visual artifacts for presentations or communication. The PwC Corporate visual style and Auto-Deck briefing system indicate a primary use case in professional consulting contexts.

## Core Concepts & Glossary

**Nugget** — The central workspace unit. A `Nugget` (`types.ts: interface Nugget`) contains a set of documents, a set of cards, a chat message history, optional styling preferences, and an AI-generated subject line. Everything in the app operates on a selected nugget.

**Project** — A named container that groups one or more nuggets. A `Project` (`types.ts: interface Project`) stores an ordered list of `nuggetIds` and is displayed as a collapsible group in the Projects panel.

**Card** — The primary creative output unit. A `Card` (`types.ts: interface Card`) maps a heading or topic to per-`DetailLevel` synthesized text (`synthesisMap`), visual plan (`visualPlanMap`), and generated image URL (`cardUrlMap`). Cards also track a full per-level version history (`imageHistoryMap`).

**DetailLevel** — A union type (`types.ts: type DetailLevel = 'Executive' | 'Standard' | 'Detailed' | 'TitleCard' | 'TakeawayCard' | 'DirectContent'`) that controls the depth and type of card content. `Executive` targets 70–100 words, `Standard` 200–250 words, `Detailed` 450–500 words. `TitleCard` and `TakeawayCard` are cover types (identified by the `isCoverLevel()` helper). `DirectContent` copies source markdown without AI synthesis.

**Document (UploadedFile)** — A source file attached to a nugget, represented by `interface UploadedFile` in `types.ts`. Documents have a `sourceType` of `'markdown'` (converted or native markdown) or `'native-pdf'` (PDF rendered in-browser). Each document carries an Anthropic Files API `fileId` for referencing in AI calls without re-uploading content.

**Subject** — A 15–30 word expert-priming sentence stored on the `Nugget` (field: `subject`), generated by `utils/subjectGeneration.ts`. It is injected into AI prompts to anchor the model's persona for that nugget's domain.

**Synthesis** — The first phase of card generation: Claude reads the nugget's documents and produces a markdown summary of the card topic at the requested `DetailLevel`. The result is stored in `card.synthesisMap[detailLevel]`.

**Visual Plan** — The second phase of card generation: a prose brief (or JSON spec for PwC Corporate) describing how the infographic should be laid out. Stored in `card.visualPlanMap[detailLevel]`.

**MetaTOC** — A companion file for native PDFs uploaded to the Anthropic Files API. Its content is a heading hierarchy in the format `# heading text (page N)`, giving Claude a structured navigation map for the PDF without embedding the full PDF text in the prompt. Managed by `utils/metaToc.ts`.

**Files API** — The Anthropic Files API (beta, `files-api-2025-04-14`). Documents and MetaTOC files are uploaded once and referenced by `fileId` in subsequent Claude API calls. Uploads go through a Vite dev server proxy at `/api/anthropic-files` to work around CORS restrictions on the beta endpoint.

**Auto-Deck** — An automated card-deck generation feature driven by a user-authored briefing. The `useAutoDeck` hook runs a state machine (configuring → planning → conflict → reviewing → revising → finalizing → producing → complete) to plan, review, and produce an entire set of cards without per-card user interaction.

**Briefing** — The structured input to Auto-Deck. `interface AutoDeckBriefing` in `types.ts` captures `audience`, `type`, `objective`, `tone`, `focus`, and optional card count constraints and cover/section/closing card flags.

**LOD (Level of Detail)** — The Auto-Deck analogue of `DetailLevel`. `type AutoDeckLod = 'executive' | 'standard' | 'detailed'` maps to the corresponding `DetailLevel` values for producer-generated card content.

**Style (StylingOptions)** — Per-nugget visual configuration stored as `interface StylingOptions` in `types.ts`. Fields include `style` (one of 15 built-in style names or a custom style name), `palette` (5-color `Palette`), `fonts` (`FontPair` with primary and secondary font families), `aspectRatio`, and `resolution`. The `DEFAULT_STYLING` exported from `utils/ai.ts` is Flat Design, 16:9, 1K.

**Palette** — A set of five hex color values (`interface Palette` in `types.ts`): `background`, `primary`, `secondary`, `accent`, and `text`. Each built-in style in `VISUAL_STYLES` (`utils/ai.ts`) defines one palette.

**Cover Card (TitleCard / TakeawayCard)** — Cards with `DetailLevel` of `'TitleCard'` or `'TakeawayCard'`, identified by `isCoverLevel()` in `types.ts`. They use dedicated prompt builders (`buildCoverContentPrompt`, `buildCoverPlannerPrompt`, `buildCoverVisualizerPrompt` in `utils/prompts/coverGeneration.ts`) and the PwC equivalents in `utils/prompts/pwcGeneration.ts`.

**Native PDF** — A PDF document processed in native mode: the raw PDF is stored as `pdfBase64` in the `UploadedFile`, rendered in-browser via `pdfjs-dist`, and its heading structure is extracted by Gemini Flash into a `Heading[]` array. The PDF and a companion MetaTOC file are both uploaded to the Anthropic Files API. Contrast with converted PDFs, which are converted to markdown by Gemini Flash first.

**Insights Lab** — The chat feature (`hooks/useInsightsLab.ts`, `components/ChatPanel.tsx`) that lets users converse with Claude about the nugget's documents. Chat responses can be saved as cards directly from the chat panel.

**Prompt caching** — Anthropic's prompt caching feature: system blocks and the last user message in each API call are marked with `cache_control: { type: 'ephemeral' }` when they exceed 4,000 characters (`CACHE_MIN_CHARS` in `utils/ai.ts`). This reduces token costs and latency for repeated calls with the same document context.

## Tech Stack

| Technology | Version | Role |
|---|---|---|
| TypeScript | 5.8.2 | Primary language |
| React | 19.2.4 | UI framework (Hooks + Context API, no class components) |
| Vite | 6.2.0 | Build tool and dev server (with dev proxy for Files API) |
| `@vitejs/plugin-react` | ^5.0.0 | React fast-refresh and JSX transform |
| `@google/genai` | ^1.41.0 | Google Gemini SDK (text and image generation) |
| `marked` | 15.0.7 | Markdown to HTML parsing |
| `pdfjs-dist` | ^5.4.624 | In-browser PDF rendering for native PDFs |
| `react-dom` | ^19.2.4 | DOM rendering + `createPortal` for panel overlays |
| Tailwind CSS | CDN (not npm) | Utility-class styling loaded via `<script>` in `index.html` |
| IndexedDB | Browser native | Persistence via custom `IndexedDBBackend` class (`infonugget-db` v5) |
| Claude Sonnet 4.6 | `claude-sonnet-4-6` | Content synthesis, visual planning, chat, Auto-Deck planning/production |
| Gemini 2.5 Flash | `gemini-2.5-flash` | PDF conversion, heading extraction, text-only planning tasks |
| Gemini Pro Image | `gemini-3-pro-image-preview` | Infographic image generation |

## High-Level Architecture

InfoNugget is a purely client-side SPA with no backend. All AI API calls are made directly from the browser using injected build-time API keys. The Anthropic Files API endpoint is proxied through the Vite dev server to work around CORS restrictions on the beta endpoint. Application state is managed through a single React Context (`AppContext`) and persisted to IndexedDB automatically via debounced save logic in `usePersistence`. The UI is a six-panel flex layout with conditional rendering rather than a client-side router.

```
Browser (React SPA)
  ├─ AppContext (context/AppContext.tsx)  ← all global state
  │    └─ usePersistence (hooks/usePersistence.ts)  ← IndexedDB auto-save
  │
  ├─ Claude API  (direct fetch to https://api.anthropic.com/v1/messages)
  │    └─ Files API  (proxied: /api/anthropic-files → api.anthropic.com/v1/files)
  │
  ├─ Gemini API  (@google/genai SDK, text + image modalities)
  │
  └─ IndexedDB   (infonugget-db v5, 14 object stores)

Entry chain:
  index.tsx
    → StorageProvider   (hydrates IndexedDB state)
      → ToastProvider   (global toast notifications)
        → AppProvider   (AppContext — all global state + CRUD helpers)
          → PersistenceConnector  (bridges AppContext → usePersistence)
            → App.tsx   (main orchestrator, ~1700 lines, all panels and modals)
```
